"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("./constants");
var Emitter = /** @class */ (function () {
    function Emitter() {
        this.listeners = {};
        this.namespace = '';
    }
    /**
     * Create an event name with optional namespace.
     */
    Emitter.prototype.createEventName = function (name) {
        if (this.namespace && !name.startsWith(this.namespace)) {
            return this.namespace + "." + name;
        }
        return name;
    };
    /**
     * Syncronously execute listeners for the defined event and arguments.
     */
    Emitter.prototype.emit = function (name, args) {
        if (args === void 0) { args = []; }
        Array.from(this.getListeners(this.createEventName(name))).some(function (listener) { return listener.apply(void 0, args) === false; });
        return this;
    };
    /**
     * Syncronously execute listeners for the defined event and arguments,
     * with the ability to intercept and abort early with a value.
     */
    // emitCascade<T>(name: string, args: EventArguments = []): T | void {
    //   let value;
    //   Array.from(this.getListeners(this.createEventName(name))).some(listener => {
    //     value = listener(...args);
    //     return typeof value !== 'undefined';
    //   });
    //   return value;
    // }
    /**
     * Remove all listeners for the defined event name.
     */
    Emitter.prototype.flushListeners = function (eventName) {
        this.getListeners(eventName).clear();
        return this;
    };
    /**
     * Return all event names with registered listeners.
     */
    Emitter.prototype.getEventNames = function () {
        return Object.keys(this.listeners);
    };
    /**
     * Return a set of listeners for a specific event name.
     */
    Emitter.prototype.getListeners = function (eventName) {
        if (!eventName.match(constants_1.APP_NAME_PATTERN)) {
            throw new Error("Invalid event name \"" + eventName + "\". " +
                'May only contain dashes, periods, and lowercase characters.');
        }
        if (!this.listeners[eventName]) {
            this.listeners[eventName] = new Set();
        }
        return this.listeners[eventName];
    };
    /**
     * Remove a listener function from a specific event name.
     */
    Emitter.prototype.off = function (eventName, listener) {
        this.getListeners(eventName).delete(listener);
        return this;
    };
    /**
     * Register a listener function to a specific event name.
     */
    Emitter.prototype.on = function (eventName, listener) {
        if (typeof listener !== 'function') {
            throw new TypeError("Invalid event listener for \"" + eventName + "\", must be a function.");
        }
        this.getListeners(eventName).add(listener);
        return this;
    };
    /**
     * Set the namespace.
     */
    Emitter.prototype.setEventNamespace = function (namespace) {
        this.namespace = namespace;
        return this;
    };
    /**
     * Remove the namespace.
     */
    Emitter.prototype.removeEventNamespace = function () {
        this.namespace = '';
        return this;
    };
    return Emitter;
}());
exports.default = Emitter;
