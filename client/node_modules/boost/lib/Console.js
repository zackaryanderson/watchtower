"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable unicorn/no-hex-escape, no-param-reassign */
var optimal_1 = __importStar(require("optimal"));
var Emitter_1 = __importDefault(require("./Emitter"));
exports.REFRESH_RATE = 100;
exports.BG_REFRESH_RATE = 500;
var Console = /** @class */ (function (_super) {
    __extends(Console, _super);
    function Console(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.bufferedOutput = '';
        _this.bufferedStreams = [];
        _this.errorLogs = [];
        _this.refreshTimer = null;
        _this.lastOutputHeight = 0;
        _this.logs = [];
        _this.renderTimer = null;
        _this.restoreCursorOnExit = false;
        /**
         * Handle uncaught exceptions and unhandled rejections that bubble up.
         */
        _this.handleFailure = function (error) {
            _this.exit(error, 1, true);
        };
        /**
         * Handle the final render before exiting.
         */
        _this.handleFinalRender = function (error) {
            if (error === void 0) { error = null; }
            _this.resetTimers();
            _this.clearLinesOutput();
            _this.flushBufferedStreams();
            _this.displayHeader();
            _this.emit('render');
            if (error) {
                _this.emit('error', [error]);
            }
            else if (_this.errorLogs.length > 0) {
                _this.displayLogs(_this.errorLogs);
            }
            else if (_this.logs.length > 0) {
                _this.displayLogs(_this.logs);
            }
            _this.displayFooter();
            _this.flushBufferedOutput();
            _this.flushBufferedStreams();
            // Remover listeners so that we avoid unwanted re-renders
            _this.flushListeners('render');
            _this.flushListeners('error');
        };
        /**
         * Handle the entire rendering and flushing process.
         */
        _this.handleRender = function (error, final) {
            if (error === void 0) { error = null; }
            if (final === void 0) { final = false; }
            _this.resetTimers();
            _this.clearLinesOutput();
            _this.flushBufferedStreams();
            _this.emit('render');
            if (error) {
                _this.emit('error', [error]);
            }
            _this.flushBufferedOutput();
        };
        /**
         * Handle SIGINT and SIGTERM interruptions.
         */
        _this.handleSignal = function () {
            _this.exit('Process has been terminated.', 1, true);
        };
        _this.options = optimal_1.default(options, {
            footer: optimal_1.string().empty(),
            header: optimal_1.string().empty(),
            level: optimal_1.number(3).between(0, 3, true),
            silent: optimal_1.bool(),
            theme: optimal_1.string('default'),
        }, {
            name: _this.constructor.name,
        });
        /* istanbul ignore next */
        if (process.env.NODE_ENV === 'test') {
            _this.err = function () { };
            _this.out = function () { };
        }
        else {
            _this.err = _this.wrapStream(process.stderr);
            _this.out = _this.wrapStream(process.stdout);
            _this.startBackgroundTimer();
            process
                .on('SIGINT', _this.handleSignal)
                .on('SIGTERM', _this.handleSignal)
                .on('uncaughtException', _this.handleFailure)
                .on('unhandledRejection', _this.handleFailure);
        }
        return _this;
    }
    /**
     * Clear the entire console.
     */
    Console.prototype.clearOutput = function () {
        this.out('\x1Bc');
        this.lastOutputHeight = 0;
        return this;
    };
    /**
     * Clear defined lines from the console.
     */
    Console.prototype.clearLinesOutput = function () {
        this.out('\x1B[1A\x1B[K'.repeat(this.lastOutputHeight));
        this.lastOutputHeight = 0;
        return this;
    };
    /**
     * Display a footer after all final output.
     */
    Console.prototype.displayFooter = function () {
        var footer = this.options.footer;
        if (footer) {
            this.write(footer, 1);
        }
    };
    /**
     * Display a header before all final output.
     */
    Console.prototype.displayHeader = function () {
        var header = this.options.header;
        if (header) {
            this.write(header, 1);
        }
    };
    /**
     * Display logs in the final output.
     */
    Console.prototype.displayLogs = function (logs) {
        if (logs.length > 0) {
            this.write("\n" + logs.join('\n') + "\n");
        }
    };
    /**
     * Force exit the application.
     */
    Console.prototype.exit = function (message, code, force) {
        if (code === void 0) { code = 1; }
        if (force === void 0) { force = false; }
        var error = null;
        if (message !== null) {
            error = message instanceof Error ? message : new Error(message);
        }
        this.emit('stop', [error, code]);
        // Render final output
        this.handleFinalRender(error);
        // Unwrap our streams
        this.unwrapStream(process.stderr);
        this.unwrapStream(process.stdout);
        // Run in the next tick so that listeners have a chance to run
        process.nextTick(function () {
            if (force) {
                // eslint-disable-next-line unicorn/no-process-exit
                process.exit(code);
            }
            else {
                process.exitCode = code;
            }
        });
    };
    /**
     * Flush buffered output that has been logged.
     */
    Console.prototype.flushBufferedOutput = function () {
        var lines = this.bufferedOutput;
        if (lines) {
            this.out(lines);
            this.lastOutputHeight = Math.max(lines.split('\n').length - 1, 0);
        }
        this.bufferedOutput = '';
        return this;
    };
    /**
     * Flush buffered streams output after clearing lines rendered by the reporter.
     */
    Console.prototype.flushBufferedStreams = function () {
        this.bufferedStreams.forEach(function (buffer) {
            buffer();
        });
        return this;
    };
    /**
     * Hide the console cursor.
     */
    Console.prototype.hideCursor = function () {
        var _this = this;
        this.out('\x1B[?25l');
        if (!this.restoreCursorOnExit) {
            this.restoreCursorOnExit = true;
            /* istanbul ignore next */
            process.on('exit', function () {
                _this.showCursor();
            });
        }
        return this;
    };
    /**
     * Store the log message.
     */
    Console.prototype.log = function (message) {
        this.logs.push(message);
        return this;
    };
    /**
     * Store the error message.
     */
    Console.prototype.logError = function (message) {
        this.errorLogs.push(message);
        return this;
    };
    /**
     * Debounce the render as to avoid tearing.
     */
    Console.prototype.render = function () {
        var _this = this;
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
            this.refreshTimer = null;
        }
        if (!this.renderTimer) {
            this.renderTimer = setTimeout(function () {
                _this.handleRender();
            }, exports.REFRESH_RATE);
        }
        return this;
    };
    /**
     * Reset the cursor back to the bottom of the console.
     */
    Console.prototype.resetCursor = function () {
        this.out("\u001B[" + process.stdout.rows + ";0H");
        return this;
    };
    /**
     * Reset both the render and background refresh timers.
     */
    Console.prototype.resetTimers = function () {
        if (this.renderTimer) {
            clearTimeout(this.renderTimer);
            this.renderTimer = null;
        }
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
            this.refreshTimer = null;
        }
        return this;
    };
    /**
     * Show the console cursor.
     */
    Console.prototype.showCursor = function () {
        this.out('\x1B[?25h');
        return this;
    };
    /**
     * Automatically refresh in the background if some tasks are taking too long.
     */
    Console.prototype.startBackgroundTimer = function () {
        var _this = this;
        this.refreshTimer = setTimeout(function () {
            _this.handleRender();
            _this.startBackgroundTimer();
        }, exports.BG_REFRESH_RATE);
    };
    /**
     * Unwrap a stream and reset it back to normal.
     */
    Console.prototype.unwrapStream = function (stream) {
        if (process.env.NODE_ENV !== 'test') {
            // @ts-ignore
            stream.write = stream.originalWrite;
        }
    };
    /**
     * Wrap a stream and buffer the output as to not collide with our reporter.
     */
    /* istanbul ignore next */
    Console.prototype.wrapStream = function (stream) {
        var originalWrite = stream.write.bind(stream);
        if (process.env.NODE_ENV === 'test') {
            return originalWrite;
        }
        var buffer = '';
        var write = function (message) {
            if (stream.isTTY) {
                originalWrite(message);
            }
        };
        var flush = function () {
            if (stream.isTTY && buffer) {
                originalWrite(buffer);
            }
            buffer = '';
        };
        this.bufferedStreams.push(flush);
        stream.write = function (chunk) {
            buffer += String(chunk);
            return true;
        };
        // @ts-ignore
        stream.originalWrite = originalWrite;
        return write;
    };
    /**
     * Log a message to `stdout` without a trailing newline or formatting.
     */
    Console.prototype.write = function (message, nl, prepend) {
        if (nl === void 0) { nl = 0; }
        if (prepend === void 0) { prepend = false; }
        if (this.options.silent) {
            return this;
        }
        var buffer = message + '\n'.repeat(nl);
        if (prepend) {
            this.bufferedOutput = buffer + this.bufferedOutput;
        }
        else {
            this.bufferedOutput += buffer;
        }
        return this;
    };
    return Console;
}(Emitter_1.default));
exports.default = Console;
