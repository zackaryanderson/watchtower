"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cli_truncate_1 = __importDefault(require("cli-truncate"));
var Reporter_1 = __importDefault(require("../Reporter"));
var Routine_1 = __importDefault(require("../Routine"));
var DefaultReporter = /** @class */ (function (_super) {
    __extends(DefaultReporter, _super);
    function DefaultReporter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.depth = 0;
        _this.keyLength = 0;
        _this.handleStart = function (routines) {
            _this.keyLength = _this.calculateKeyLength(routines);
        };
        _this.handleCommand = function () {
            _this.console.render();
        };
        _this.handleTask = function (task, routine) {
            var line = _this.findLine(function (row) { return row.routine === routine; });
            if (line) {
                line.tasks.push(task);
            }
            _this.console.render();
        };
        _this.handleTaskComplete = function (task, routine) {
            var line = _this.findLine(function (row) { return row.routine === routine; });
            if (line) {
                line.tasks = line.tasks.filter(function (t) { return t !== task; });
            }
            _this.console.render();
        };
        _this.handleRender = function () {
            _this.lines.forEach(function (_a) {
                var routine = _a.routine, tasks = _a.tasks, depth = _a.depth;
                _this.renderLine(routine, null, depth);
                tasks.forEach(function (task) {
                    _this.renderLine(routine, task, depth);
                });
            });
        };
        _this.handleRoutine = function (routine, value, wasParallel) {
            _this.addLine({
                depth: _this.depth,
                routine: routine,
                tasks: [],
            });
            _this.console.render();
            if (!wasParallel) {
                _this.depth += 1;
            }
        };
        _this.handleRoutineComplete = function (routine, result, wasParallel) {
            if (!wasParallel) {
                _this.depth -= 1;
            }
            if (_this.depth > 0 && _this.console.options.level < 3) {
                _this.removeLine(function (line) { return line.routine === routine; });
            }
            _this.console.render();
        };
        return _this;
    }
    DefaultReporter.prototype.bootstrap = function () {
        this.console
            .on('start', this.handleStart)
            .on('task', this.handleTask)
            .on('task.pass', this.handleTaskComplete)
            .on('task.fail', this.handleTaskComplete)
            .on('routine', this.handleRoutine)
            .on('routine.pass', this.handleRoutineComplete)
            .on('routine.fail', this.handleRoutineComplete)
            .on('command.data', this.handleCommand)
            .on('render', this.handleRender);
    };
    /**
     * Calculate the max string length for routine key's at every depth.
     */
    DefaultReporter.prototype.calculateKeyLength = function (routines, depth) {
        var _this = this;
        if (depth === void 0) { depth = 0; }
        return routines.reduce(function (sum, routine) {
            return Math.max(sum, routine.key.length + depth, _this.calculateKeyLength(routine.routines, depth + 1));
        }, 0);
    };
    /**
     * Calculate the current number of tasks that have completed.
     */
    DefaultReporter.prototype.calculateTaskCompletion = function (tasks) {
        return tasks.reduce(function (sum, task) { return (task.hasPassed() || task.isSkipped() ? sum + 1 : sum); }, 0);
    };
    /**
     * Return the task title with additional metadata.
     */
    // eslint-disable-next-line complexity
    DefaultReporter.prototype.getLineTitle = function (task, usedColumns) {
        if (usedColumns === void 0) { usedColumns = 0; }
        var level = this.console.options.level;
        // @ts-ignore
        var _a = task.tasks, tasks = _a === void 0 ? [] : _a, _b = task.routines, routines = _b === void 0 ? [] : _b;
        var title = task.statusText ? this.style(task.statusText) : task.title;
        var status = [];
        if (task.isSkipped()) {
            status.push(this.style('skipped', 'warning'));
        }
        else if (task.hasFailed()) {
            status.push(this.style('failed', 'failure'));
        }
        else if (tasks.length > 0) {
            status.push(this.calculateTaskCompletion(tasks) + "/" + tasks.length);
        }
        else if (routines.length > 0) {
            status.push(this.calculateTaskCompletion(routines) + "/" + routines.length);
        }
        if (task instanceof Routine_1.default && !task.isSkipped() && level >= 2) {
            status.push(this.getElapsedTime(task.startTime, task.stopTime));
        }
        // eslint-disable-next-line no-magic-numbers
        var columns = process.stdout.columns || 80;
        var fullStatus = status.length > 0 && level >= 1 ? this.style(" [" + status.join(', ') + "]") : '';
        return cli_truncate_1.default(title, columns - usedColumns - fullStatus.length) + fullStatus;
    };
    DefaultReporter.prototype.renderLine = function (routine, task, depth) {
        var indent = depth * 2;
        var key = this.indent(depth) + (task ? '' : routine.key.toUpperCase()).padEnd(this.keyLength - depth);
        var output = '';
        // Status
        output += this.style(key, this.getColorType(routine), ['bold']);
        output += '  ';
        // Tree
        if (depth > 0) {
            if (task) {
                output += this.indent(indent);
            }
            else {
                output += this.indent(indent - 2);
                output += this.style('â””');
                output += ' ';
            }
        }
        // Title
        var usedColumns = indent + key.length;
        if (task) {
            output += this.style(this.getLineTitle(task, usedColumns));
        }
        else {
            output += this.getLineTitle(routine, usedColumns);
        }
        this.console.write(output, 1);
    };
    return DefaultReporter;
}(Reporter_1.default));
exports.default = DefaultReporter;
