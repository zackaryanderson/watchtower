"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chalk_1 = __importDefault(require("chalk"));
var fs_1 = __importDefault(require("fs"));
var glob_1 = __importDefault(require("glob"));
var path_1 = __importDefault(require("path"));
var json5_1 = __importDefault(require("json5"));
var camelCase_1 = __importDefault(require("lodash/camelCase"));
var mergeWith_1 = __importDefault(require("lodash/mergeWith"));
var pluralize_1 = __importDefault(require("pluralize"));
var optimal_1 = __importStar(require("optimal"));
var formatModuleName_1 = __importDefault(require("./helpers/formatModuleName"));
var isObject_1 = __importDefault(require("./helpers/isObject"));
var isEmptyObject_1 = __importDefault(require("./helpers/isEmptyObject"));
var requireModule_1 = __importDefault(require("./helpers/requireModule"));
var Plugin_1 = __importDefault(require("./Plugin"));
var Reporter_1 = __importDefault(require("./Reporter"));
var constants_1 = require("./constants");
var ConfigLoader = /** @class */ (function () {
    function ConfigLoader(tool) {
        this.package = { name: '' };
        this.parsedFiles = {};
        this.workspaceRoot = '';
        this.debug = tool.createDebugger('config-loader');
        this.tool = tool;
    }
    /**
     * Find the config in the package.json block under the application name.
     */
    ConfigLoader.prototype.findConfigInPackageJSON = function (pkg) {
        var camelName = camelCase_1.default(this.tool.options.appName);
        var config = pkg[camelName];
        this.debug.invariant(!!config, "Looking in package.json under " + chalk_1.default.yellow(camelName) + " property", 'Found', 'Not found');
        if (!config) {
            return null;
        }
        // Extend from a preset if a string
        if (typeof config === 'string') {
            return { extends: [config] };
        }
        return config;
    };
    /**
     * Find the config using local files commonly located in a configs/ folder.
     */
    ConfigLoader.prototype.findConfigInLocalFiles = function (root) {
        var _a = this.tool.options, appName = _a.appName, configFolder = _a.configFolder;
        var relPath = path_1.default.join(configFolder, appName + ".{js,json,json5}");
        var configPaths = glob_1.default.sync(path_1.default.join(root, relPath), {
            absolute: true,
        });
        this.debug.invariant(configPaths.length === 1, "Looking for local config file in order: " + relPath, 'Found', 'Not found');
        if (configPaths.length === 1) {
            this.debug('Found %s', path_1.default.basename(configPaths[0]));
            return configPaths[0];
        }
        if (configPaths.length > 1) {
            throw new Error("Multiple \"" + appName + "\" configuration files found. Only 1 may exist.");
        }
        return null;
    };
    /**
     * Find the config within the root when in a workspace.
     */
    // eslint-disable-next-line complexity
    ConfigLoader.prototype.findConfigInWorkspaceRoot = function (root) {
        var currentDir = path_1.default.dirname(root);
        if (currentDir.includes('node_modules')) {
            return null;
        }
        this.debug('Detecting if in a workspace');
        var workspaceRoot = '';
        var workspacePackage = {};
        var workspacePatterns = [];
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (!currentDir || currentDir === '.' || currentDir === '/') {
                break;
            }
            var pkgPath = path_1.default.join(currentDir, 'package.json');
            var lernaPath = path_1.default.join(currentDir, 'lerna.json');
            // Yarn
            if (fs_1.default.existsSync(pkgPath)) {
                workspacePackage = this.parseFile(pkgPath);
                if (workspacePackage.workspaces) {
                    if (Array.isArray(workspacePackage.workspaces)) {
                        workspaceRoot = currentDir;
                        workspacePatterns = workspacePackage.workspaces;
                    }
                    else if (Array.isArray(workspacePackage.workspaces.packages)) {
                        workspaceRoot = currentDir;
                        workspacePatterns = workspacePackage.workspaces.packages;
                    }
                    break;
                }
            }
            // Lerna
            if (workspacePackage && fs_1.default.existsSync(lernaPath)) {
                var lerna = this.parseFile(lernaPath);
                if (Array.isArray(lerna.packages)) {
                    workspaceRoot = currentDir;
                    workspacePatterns = lerna.packages;
                    break;
                }
            }
            currentDir = path_1.default.dirname(currentDir);
        }
        if (!workspaceRoot) {
            this.debug('No workspace found');
            return null;
        }
        var match = workspacePatterns.some(function (pattern) { return !!root.match(new RegExp(path_1.default.join(workspaceRoot, pattern), 'u')); });
        this.debug.invariant(match, "Matching patterns: " + workspacePatterns.map(function (p) { return chalk_1.default.cyan(p); }).join(', '), 'Match found', 'Invalid workspace package');
        if (!match) {
            return null;
        }
        this.workspaceRoot = workspaceRoot;
        return (this.findConfigInPackageJSON(workspacePackage) ||
            this.findConfigInLocalFiles(workspaceRoot) ||
            null);
    };
    /**
     * Handle special cases when merging 2 configuration values.
     * If the target and source are both arrays, concatenate them.
     */
    ConfigLoader.prototype.handleMerge = function (target, source) {
        if (Array.isArray(target) && Array.isArray(source)) {
            return Array.from(new Set(target.concat(source)));
        }
        // Defer to lodash
        return undefined;
    };
    /**
     * Load a local configuration file relative to the current working directory,
     * or from within a package.json property of the same appName.
     *
     * Support both JSON and JS file formats by globbing the config directory.
     */
    ConfigLoader.prototype.loadConfig = function () {
        var _a, _b;
        if (isEmptyObject_1.default(this.package) || !this.package.name) {
            throw new Error('Cannot load configuration as "package.json" has not been loaded.');
        }
        this.debug('Locating configuration');
        var _c = this.tool.options, configBlueprint = _c.configBlueprint, pluginAlias = _c.pluginAlias, root = _c.root;
        var config = this.findConfigInPackageJSON(this.package) ||
            this.findConfigInLocalFiles(root) ||
            this.findConfigInWorkspaceRoot(root);
        if (!config) {
            throw new Error('Local configuration file or package.json property could not be found.');
        }
        // Parse and extend configuration
        return optimal_1.default(this.parseAndExtend(config), __assign({}, configBlueprint, (_a = { debug: optimal_1.bool(), extends: optimal_1.array(optimal_1.string()), 
                // prettier-ignore
                reporters: optimal_1.array(optimal_1.union([
                    optimal_1.string(),
                    optimal_1.shape({ reporter: optimal_1.string() }),
                    optimal_1.instance(Reporter_1.default),
                ])) }, _a[pluralize_1.default(pluginAlias)] = optimal_1.array(optimal_1.union([
            optimal_1.string(),
            optimal_1.shape((_b = {}, _b[pluginAlias] = optimal_1.string(), _b)),
            optimal_1.instance(Plugin_1.default),
        ])), _a)), {
            name: 'ConfigLoader',
            unknown: true,
        });
    };
    /**
     * Load the "package.json" from the current working directory,
     * as we require the build tool to be ran from the project root.
     */
    ConfigLoader.prototype.loadPackageJSON = function () {
        var root = this.tool.options.root;
        var filePath = path_1.default.join(root, 'package.json');
        this.debug('Locating package.json in %s', chalk_1.default.cyan(root));
        if (!fs_1.default.existsSync(filePath)) {
            throw new Error('Local "package.json" could not be found. Please run the command in your project\'s root.');
        }
        this.package = optimal_1.default(this.parseFile(filePath), {
            name: optimal_1.string(),
        }, {
            name: 'ConfigLoader',
            unknown: true,
        });
        return this.package;
    };
    /**
     * If an `extends` option exists, recursively merge the current configuration
     * with the preset configurations defined within `extends`,
     * and return the new configuration object.
     */
    ConfigLoader.prototype.parseAndExtend = function (fileOrConfig) {
        var _this = this;
        var config;
        var baseDir = '';
        // Parse out the object if a file path
        if (typeof fileOrConfig === 'string') {
            config = this.parseFile(fileOrConfig);
            baseDir = path_1.default.dirname(fileOrConfig);
        }
        else {
            config = fileOrConfig;
        }
        // Verify we're working with an object
        if (!isObject_1.default(config)) {
            throw new Error('Invalid configuration. Must be a plain object.');
        }
        var extendPaths = config.extends;
        // Nothing to extend, so return the current config
        if (!extendPaths || extendPaths.length === 0) {
            return config;
        }
        // Resolve extend paths and inherit their config
        var nextConfig = {};
        var resolvedPaths = this.resolveExtendPaths(extendPaths, baseDir);
        resolvedPaths.forEach(function (extendPath) {
            if (_this.parsedFiles[extendPath]) {
                return;
            }
            if (!fs_1.default.existsSync(extendPath)) {
                throw new Error("Preset configuration " + extendPath + " does not exist.");
            }
            else if (!fs_1.default.statSync(extendPath).isFile()) {
                throw new Error("Preset configuration " + extendPath + " must be a valid file.");
            }
            _this.debug('Extending from file %s', chalk_1.default.cyan(extendPath));
            mergeWith_1.default(nextConfig, _this.parseAndExtend(extendPath), _this.handleMerge);
        });
        // Apply the current config after extending preset configs
        config.extends = resolvedPaths;
        mergeWith_1.default(nextConfig, config, this.handleMerge);
        return nextConfig;
    };
    /**
     * Parse a configuration file at the defined file system path.
     * If the file ends in "json" or "json5", parse it with JSON5.
     * If the file ends in "js", import the file and use the default object.
     * Otherwise throw an error.
     */
    ConfigLoader.prototype.parseFile = function (filePath, args) {
        if (args === void 0) { args = []; }
        var name = path_1.default.basename(filePath);
        var ext = path_1.default.extname(filePath);
        var value = null;
        this.debug('Parsing file %s', chalk_1.default.cyan(filePath));
        if (!path_1.default.isAbsolute(filePath)) {
            throw new Error('An absolute file path is required.');
        }
        if (ext === '.json' || ext === '.json5') {
            value = json5_1.default.parse(fs_1.default.readFileSync(filePath, 'utf8'));
        }
        else if (ext === '.js') {
            value = requireModule_1.default(filePath);
            if (typeof value === 'function') {
                value = value.apply(void 0, args);
            }
        }
        else {
            throw new Error("Unsupported configuration file format \"" + name + "\".");
        }
        if (!isObject_1.default(value)) {
            throw new Error("Invalid configuration file \"" + name + "\". Must return an object.");
        }
        this.parsedFiles[filePath] = true;
        return value;
    };
    /**
     * Resolve file system paths for the `extends` configuration value
     * using the following guidelines:
     *
     *  - Absolute paths should be normalized and used as is.
     *  - Relative paths should be resolved relative to the CWD.
     *  - Strings that match a node module name should resolve to a config file relative to the CWD.
     *  - Strings that start with "<plugin>:" should adhere to the previous rule.
     */
    ConfigLoader.prototype.resolveExtendPaths = function (extendPaths, baseDir) {
        var _this = this;
        if (baseDir === void 0) { baseDir = ''; }
        return extendPaths.map(function (extendPath) {
            if (typeof extendPath !== 'string') {
                throw new TypeError('Invalid `extends` configuration value. Must be an array of strings.');
            }
            var _a = _this.tool.options, appName = _a.appName, scoped = _a.scoped, pluginAlias = _a.pluginAlias, root = _a.root;
            // Absolute path, use it directly
            if (path_1.default.isAbsolute(extendPath)) {
                return path_1.default.normalize(extendPath);
                // Relative path, resolve with parent folder or cwd
            }
            else if (extendPath[0] === '.') {
                return path_1.default.resolve(baseDir || root, extendPath);
                // Node module, resolve to a config file
            }
            else if (extendPath.match(constants_1.MODULE_NAME_PATTERN)) {
                return _this.resolveModuleConfigPath(appName, extendPath, true);
                // Plugin, resolve to a node module
            }
            else if (extendPath.match(constants_1.PLUGIN_NAME_PATTERN)) {
                return _this.resolveModuleConfigPath(appName, formatModuleName_1.default(appName, pluginAlias, extendPath, scoped), true);
            }
            throw new Error("Invalid `extends` configuration value \"" + extendPath + "\".");
        });
    };
    /**
     * Resolve a Node/NPM module path to an app config file.
     */
    ConfigLoader.prototype.resolveModuleConfigPath = function (appName, moduleName, preset, ext) {
        if (preset === void 0) { preset = false; }
        if (ext === void 0) { ext = 'js'; }
        var fileName = preset ? appName + ".preset." + ext : appName + "." + ext;
        var configFolder = this.tool.options.configFolder;
        return path_1.default.resolve(this.tool.options.root, 'node_modules', moduleName, configFolder, fileName);
    };
    return ConfigLoader;
}());
exports.default = ConfigLoader;
