"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chalk_1 = __importDefault(require("chalk"));
var path_1 = __importDefault(require("path"));
var upperFirst_1 = __importDefault(require("lodash/upperFirst"));
var pluralize_1 = __importDefault(require("pluralize"));
var formatModuleName_1 = __importDefault(require("./helpers/formatModuleName"));
var isObject_1 = __importDefault(require("./helpers/isObject"));
var requireModule_1 = __importDefault(require("./helpers/requireModule"));
var ModuleLoader = /** @class */ (function () {
    function ModuleLoader(tool, typeName, classReference) {
        this.classReference = classReference;
        this.debug = tool.createDebugger(typeName + "-loader");
        this.tool = tool;
        this.typeName = typeName;
        this.debug('Loading %s', chalk_1.default.green(pluralize_1.default(typeName)));
    }
    /**
     * Import a class definition from a Node module and instantiate the class
     * with the provided options object.
     */
    ModuleLoader.prototype.importModule = function (name, args) {
        var _this = this;
        if (args === void 0) { args = []; }
        var typeName = this.typeName;
        var _a = this.tool.options, appName = _a.appName, scoped = _a.scoped;
        // Determine modules to attempt to load
        var modulesToAttempt = [];
        var isFilePath = false;
        var importedModule = null;
        var moduleName;
        // File path
        if (name.match(/^\.|\/|\\|[A-Z]:/u)) {
            this.debug('Locating %s from path %s', typeName, chalk_1.default.cyan(name));
            modulesToAttempt.push(path_1.default.normalize(name));
            isFilePath = true;
            // Module name
        }
        else {
            this.debug('Locating %s module %s', typeName, chalk_1.default.yellow(name));
            modulesToAttempt.push(formatModuleName_1.default(appName, typeName, name, false));
            if (scoped) {
                modulesToAttempt.unshift(formatModuleName_1.default(appName, typeName, name, true));
            }
            this.debug('Resolving in order: %s', modulesToAttempt.join(', '));
        }
        modulesToAttempt.some(function (modName) {
            try {
                importedModule = requireModule_1.default(modName);
                moduleName = modName;
                return true;
            }
            catch (error) {
                _this.debug('Failed to import module: %s', error.message);
                return false;
            }
        });
        if (!importedModule || !moduleName) {
            throw new Error("Missing " + typeName + ". Attempted import in order: " + modulesToAttempt.join(', '));
        }
        // An instance was returned instead of the class definition
        if (importedModule instanceof this.classReference) {
            throw new TypeError("A " + typeName + " class instance was exported from \"" + moduleName + "\". " +
                (upperFirst_1.default(appName) + " requires a " + typeName + " class definition to be exported."));
        }
        else if (typeof importedModule !== 'function') {
            throw new TypeError("Invalid " + typeName + " class definition exported from \"" + moduleName + "\".");
        }
        var ModuleClass = importedModule;
        var module = new (ModuleClass.bind.apply(ModuleClass, [void 0].concat(args)))();
        if (!(module instanceof this.classReference)) {
            throw new TypeError(upperFirst_1.default(typeName) + " exported from \"" + moduleName + "\" is invalid.");
        }
        if (isFilePath) {
            this.debug('Found with file path %s', chalk_1.default.cyan(moduleName));
        }
        else {
            this.debug('Found with module %s', chalk_1.default.yellow(moduleName));
            module.name = name;
            module.moduleName = moduleName;
        }
        return module;
    };
    /**
     * If loading from an object, extract the module name and use the remaining object
     * as options for the class instance.
     */
    ModuleLoader.prototype.importModuleFromOptions = function (baseOptions, args) {
        if (args === void 0) { args = []; }
        var typeName = this.typeName;
        var options = __assign({}, baseOptions);
        var module = options[typeName];
        delete options[typeName];
        if (!module || typeof module !== 'string') {
            throw new TypeError("A \"" + typeName + "\" property must exist when loading through an options object.");
        }
        var nextArgs = args.slice();
        if (nextArgs.length === 0) {
            nextArgs.push(options);
        }
        else if (isObject_1.default(nextArgs[0])) {
            nextArgs[0] = __assign({}, nextArgs[0], options);
        }
        return this.importModule(module, nextArgs);
    };
    /**
     * Load and or instantiate a module for the `typeName` configuration property.
     * If a class instance, use directly. If a string, attempt to load and
     * instantiate from a module. If an object, extract the name and run the previous.
     */
    ModuleLoader.prototype.loadModule = function (module, args) {
        if (args === void 0) { args = []; }
        if (module instanceof this.classReference) {
            return module;
        }
        else if (typeof module === 'string') {
            return this.importModule(module, args);
        }
        else if (isObject_1.default(module)) {
            return this.importModuleFromOptions(module, args);
        }
        throw new TypeError("Invalid " + this.typeName + ". Must be a class instance or a module that exports a class definition.");
    };
    /**
     * Load multiple modules.
     */
    ModuleLoader.prototype.loadModules = function (modules, args) {
        var _this = this;
        if (modules === void 0) { modules = []; }
        if (args === void 0) { args = []; }
        return modules.map(function (module) { return _this.loadModule(module, args); });
    };
    return ModuleLoader;
}());
exports.default = ModuleLoader;
