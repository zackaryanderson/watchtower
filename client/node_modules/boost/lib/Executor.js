"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var kebabCase_1 = __importDefault(require("lodash/kebabCase"));
var wrapWithPromise_1 = __importDefault(require("./helpers/wrapWithPromise"));
var Executor = /** @class */ (function () {
    function Executor(tool, context, options) {
        if (options === void 0) { options = {}; }
        this.context = context;
        this.debug = tool.createDebugger(kebabCase_1.default(this.constructor.name));
        this.tool = tool;
        // @ts-ignore
        this.options = __assign({}, options);
        this.debug('Instantiating task executor');
    }
    /**
     * Aggregate and partition errors and results into separate collections.
     */
    Executor.prototype.aggregateResponse = function (responses) {
        var results = [];
        var errors = [];
        this.debug('Aggregating results');
        responses.forEach(function (response) {
            if (response instanceof Error) {
                errors.push(response);
            }
            else {
                results.push(response);
            }
        });
        return { errors: errors, results: results };
    };
    /**
     * Execute either a task or routine.
     */
    Executor.prototype.execute = function (task, value, wasParallel) {
        if (wasParallel === void 0) { wasParallel = false; }
        return this.getInstanceType(task) === 'Routine'
            ? this.executeRoutine(task, value, wasParallel)
            : this.executeTask(task, value, wasParallel);
    };
    /**
     * Execute a routine with the provided value.
     */
    Executor.prototype.executeRoutine = function (routine, value, wasParallel) {
        if (wasParallel === void 0) { wasParallel = false; }
        return wrapWithPromise_1.default(routine.run(this.context, value, wasParallel));
    };
    /**
     * Execute a task with the provided value.
     */
    Executor.prototype.executeTask = function (task, value, wasParallel) {
        if (wasParallel === void 0) { wasParallel = false; }
        var cli = this.tool.console;
        cli.emit('task', [task, value, wasParallel]);
        return wrapWithPromise_1.default(task.run(this.context, value))
            .then(function (result) {
            cli.emit('task.pass', [task, result, wasParallel]);
            return result;
        })
            .catch(function (error) {
            cli.emit('task.fail', [task, error, wasParallel]);
            throw error;
        });
    };
    /**
     * Importing Routine causes a circular reference, so we can't use an instanceof check,
     * so we need to hackily check this another way.
     */
    Executor.prototype.getInstanceType = function (task) {
        var instance = task;
        var name = '';
        do {
            (name = instance.constructor.name);
            if (name === 'Routine' || name === 'Task') {
                return name;
            }
            instance = Object.getPrototypeOf(instance);
        } while (instance);
        return name;
    };
    /**
     * Method to execute tasks. Must be defined in sub-classes.
     */
    Executor.prototype.run = function (tasks, value) {
        throw new Error('run() must be defined.');
    };
    return Executor;
}());
exports.default = Executor;
