/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
import { Options as ExecaOptions, SyncOptions as ExecaSyncOptions, ExecaChildProcess, ExecaReturns } from 'execa';
import Context from './Context';
import Task, { TaskAction } from './Task';
import Tool from './Tool';
import { AggregatedResponse } from './Executor';
import { PoolExecutorOptions } from './executors/Pool';
import { Debugger } from './types';
export interface CommandOptions {
    sync?: boolean;
    task?: Task<any>;
    wrap?: (process: ExecaChildProcess) => void;
}
export default class Routine<Ctx extends Context, Options = {}> extends Task<Ctx, Options> {
    exit: boolean;
    debug: Debugger;
    key: string;
    routines: Routine<Ctx, any>[];
    tool: Tool;
    constructor(key: string, title: string, options?: Partial<Options>);
    /**
     * Called once the routine has been configured and is ready to execute.
     */
    bootstrap(): void;
    /**
     * Configure the routine after it has been instantiated.
     */
    configure(parent: Routine<Ctx>): this;
    /**
     * Execute the current routine and return a new value.
     * This method *must* be overridden in a subclass.
     */
    execute<T>(context: Ctx, value?: T): Promise<any>;
    /**
     * Execute a command with the given arguments and pass the results through a promise.
     */
    executeCommand(command: string, args: string[], options?: (ExecaOptions | ExecaSyncOptions) & CommandOptions): Promise<ExecaReturns>;
    /**
     * Execute routines in parallel.
     */
    parallelizeRoutines<T>(value?: T, routines?: Routine<Ctx>[]): Promise<any[]>;
    /**
     * Execute tasks in parallel.
     */
    parallelizeTasks<T>(value?: T, tasks?: Task<Ctx>[]): Promise<any[]>;
    /**
     * Add a new routine within this routine.
     */
    pipe(routine: Routine<Ctx>): this;
    /**
     * Execute routines in a pool.
     */
    poolRoutines<T>(value?: T, options?: Partial<PoolExecutorOptions>, routines?: Routine<Ctx>[]): Promise<AggregatedResponse>;
    /**
     * Execute tasks in a pool.
     */
    poolTasks<T>(value?: T, options?: Partial<PoolExecutorOptions>, tasks?: Task<Ctx>[]): Promise<AggregatedResponse>;
    /**
     * Trigger processes before and after execution.
     */
    run<T>(context: Ctx, value?: T, wasParallel?: boolean): Promise<any>;
    /**
     * Execute routines in sequential (serial) order.
     */
    serializeRoutines<T>(value?: T, routines?: Routine<Ctx>[]): Promise<any>;
    /**
     * Execute tasks in sequential (serial) order.
     */
    serializeTasks<T>(value?: T, tasks?: Task<Ctx>[]): Promise<any>;
    /**
     * Execute routines in sync.
     */
    synchronizeRoutines<T>(value?: T, routines?: Routine<Ctx>[]): Promise<AggregatedResponse>;
    /**
     * Execute tasks in sync.
     */
    synchronizeTasks<T>(value?: T, tasks?: Task<Ctx>[]): Promise<AggregatedResponse>;
    /**
     * Define an individual task.
     */
    task<Tp>(title: string, action: TaskAction<Ctx>, options?: Tp): Task<Ctx, Tp>;
}
