"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chalk_1 = __importDefault(require("chalk"));
var Module_1 = __importDefault(require("./Module"));
var themes_1 = __importDefault(require("./themes"));
exports.SLOW_THRESHOLD = 10000; // ms
var Reporter = /** @class */ (function (_super) {
    __extends(Reporter, _super);
    function Reporter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lines = [];
        _this.startTime = 0;
        _this.stopTime = 0;
        /**
         * Set start time.
         */
        _this.handleBaseStart = function () {
            _this.startTime = Date.now();
        };
        /**
         * Set stop time and render.
         */
        _this.handleBaseStop = function () {
            _this.stopTime = Date.now();
        };
        return _this;
    }
    /**
     * Register console listeners.
     */
    Reporter.prototype.bootstrap = function () {
        this.console.on('start', this.handleBaseStart).on('stop', this.handleBaseStop);
    };
    /**
     * Add a line to be rendered.
     */
    Reporter.prototype.addLine = function (line) {
        this.lines.push(line);
        return this;
    };
    /**
     * Display an error and it's stack.
     */
    Reporter.prototype.displayError = function (error) {
        this.console.write("\n" + this.style(error.message, 'failure', ['bold']) + "\n");
        // Remove message line from stack
        if (error.stack) {
            var stack = this.style(error.stack
                .split('\n')
                .slice(1)
                .join('\n'));
            this.console.write(stack, 1);
        }
        this.console.write('\n');
    };
    /**
     * Find a line using a callback
     */
    Reporter.prototype.findLine = function (callback) {
        return this.lines.find(function (line) { return callback(line); });
    };
    /**
     * Return specific colors based on chosen theme.
     */
    Reporter.prototype.getColorPalette = function () {
        var theme = this.console.options.theme;
        if (chalk_1.default.level >= 2 && themes_1.default[theme]) {
            return themes_1.default[theme];
        }
        return {
            failure: 'red',
            pending: 'gray',
            success: 'green',
            warning: 'yellow',
        };
    };
    /**
     * Return a specific color for each task status.
     */
    Reporter.prototype.getColorType = function (task) {
        if (task.isSkipped()) {
            return 'warning';
        }
        else if (task.hasPassed()) {
            return 'success';
        }
        else if (task.hasFailed()) {
            return 'failure';
        }
        return 'pending';
    };
    /**
     * Calculate the elapsed time and highlight as red if over the threshold.
     */
    Reporter.prototype.getElapsedTime = function (start, stop, highlight) {
        if (stop === void 0) { stop = 0; }
        if (highlight === void 0) { highlight = true; }
        var time = (stop || Date.now()) - start;
        var isSlow = time > exports.SLOW_THRESHOLD;
        var elapsed = (time / 1000).toFixed(2) + "s"; // eslint-disable-line no-magic-numbers
        return isSlow && highlight ? this.style(elapsed, 'failure') : elapsed;
    };
    /**
     * Create an indentation based on the defined length.
     */
    Reporter.prototype.indent = function (length) {
        if (length === void 0) { length = 0; }
        return ' '.repeat(length);
    };
    /**
     * Remove a line to be rendered.
     */
    Reporter.prototype.removeLine = function (callback) {
        this.lines = this.lines.filter(function (line) { return !callback(line); });
        return this;
    };
    /**
     * Create a chalk formatted string with accessible colors and modifiers applied.
     */
    Reporter.prototype.style = function (message, type, modifiers) {
        if (type === void 0) { type = 'pending'; }
        if (modifiers === void 0) { modifiers = []; }
        var color = this.getColorPalette()[type];
        var out = color.charAt(0) === '#' ? chalk_1.default.hex(color) : chalk_1.default[color];
        modifiers.forEach(function (modifier) {
            out = out[modifier];
        });
        return out(message);
    };
    return Reporter;
}(Module_1.default));
exports.default = Reporter;
