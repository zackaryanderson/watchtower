/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
import Context from './Context';
import Routine from './Routine';
import Task from './Task';
import Tool from './Tool';
import { Debugger } from './types';
export interface AggregatedResponse {
    errors: Error[];
    results: any[];
}
export default class Executor<Ctx extends Context, Options = {}> {
    context: Ctx;
    debug: Debugger;
    options: Options;
    tool: Tool;
    constructor(tool: Tool, context: Ctx, options?: Partial<Options>);
    /**
     * Aggregate and partition errors and results into separate collections.
     */
    aggregateResponse(responses: any[]): AggregatedResponse;
    /**
     * Execute either a task or routine.
     */
    execute<T>(task: Task<Ctx> | Routine<Ctx>, value?: T, wasParallel?: boolean): Promise<any>;
    /**
     * Execute a routine with the provided value.
     */
    executeRoutine<T>(routine: Routine<Ctx>, value?: T, wasParallel?: boolean): Promise<any>;
    /**
     * Execute a task with the provided value.
     */
    executeTask<T>(task: Task<Ctx>, value?: T, wasParallel?: boolean): Promise<any>;
    /**
     * Importing Routine causes a circular reference, so we can't use an instanceof check,
     * so we need to hackily check this another way.
     */
    getInstanceType(task: Task<Ctx> | Routine<Ctx>): string;
    /**
     * Method to execute tasks. Must be defined in sub-classes.
     */
    run<T>(tasks: Task<Ctx>[], value?: T): void;
}
