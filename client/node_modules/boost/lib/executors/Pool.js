"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var os_1 = __importDefault(require("os"));
var optimal_1 = __importStar(require("optimal"));
var Executor_1 = __importDefault(require("../Executor"));
var PoolExecutor = /** @class */ (function (_super) {
    __extends(PoolExecutor, _super);
    function PoolExecutor(tool, context, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, tool, context, options) || this;
        _this.queue = [];
        _this.resolver = null;
        _this.results = [];
        _this.running = [];
        _this.options = optimal_1.default(options, {
            concurrency: optimal_1.number(os_1.default.cpus().length).gte(1),
            fifo: optimal_1.bool(true),
            timeout: optimal_1.number(0).gte(0),
        });
        return _this;
    }
    /**
     * Execute tasks using a pool with a max concurrency.
     */
    PoolExecutor.prototype.run = function (tasks, value) {
        var _this = this;
        if (tasks.length === 0) {
            return Promise.resolve(this.aggregateResponse([]));
        }
        var _a = this.options, concurrency = _a.concurrency, timeout = _a.timeout;
        this.debug('Pooling %d tasks', tasks.length);
        return new Promise(function (resolve) {
            _this.queue = tasks.slice(); // Break references
            _this.resolver = resolve;
            // eslint-disable-next-line promise/catch-or-return
            Promise.all(_this.queue.slice(0, concurrency).map(function () { return _this.runTask(value); }));
            if (timeout) {
                _this.timeoutTimer = setTimeout(function () { return _this.resolve(); }, timeout);
            }
        });
    };
    /**
     * Resolve the execution with the current results.
     */
    PoolExecutor.prototype.resolve = function () {
        if (this.resolver) {
            this.resolver(this.aggregateResponse(this.results));
        }
        if (this.timeoutTimer) {
            clearTimeout(this.timeoutTimer);
        }
    };
    /**
     * Run a task from the queue, and start the next task one it passes or fails.
     */
    PoolExecutor.prototype.runTask = function (value) {
        var _this = this;
        var task = this.options.fifo ? this.queue.shift() : this.queue.pop();
        if (!task) {
            return Promise.resolve();
        }
        this.running.push(task);
        var handleResult = function (result) {
            _this.running = _this.running.filter(function (running) { return running !== task; });
            _this.results.push(result);
            _this.nextTask(value);
        };
        return this.execute(task, value, true)
            .then(handleResult)
            .catch(handleResult);
    };
    /**
     * Run the next task if there are tasks available in the queue, and the max concurrency isn't met.
     * Otherwise, resolve and exit the current pool.
     */
    PoolExecutor.prototype.nextTask = function (value) {
        if (this.queue.length > 0 && this.running.length < this.options.concurrency) {
            this.runTask(value);
        }
        else if (this.queue.length === 0 && this.running.length === 0) {
            this.resolve();
        }
    };
    return PoolExecutor;
}(Executor_1.default));
exports.default = PoolExecutor;
