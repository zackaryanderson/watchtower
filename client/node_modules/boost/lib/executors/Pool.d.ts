/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
/// <reference types="node" />
import Context from '../Context';
import Executor, { AggregatedResponse } from '../Executor';
import Task from '../Task';
import Tool from '../Tool';
export interface PoolExecutorOptions {
    concurrency: number;
    fifo: boolean;
    timeout: number;
}
export default class PoolExecutor<Ctx extends Context> extends Executor<Ctx, PoolExecutorOptions> {
    queue: Task<Ctx>[];
    resolver: ((response: AggregatedResponse) => void) | null;
    results: any[];
    running: Task<Ctx>[];
    timeoutTimer?: NodeJS.Timer;
    constructor(tool: Tool, context: Ctx, options?: Partial<PoolExecutorOptions>);
    /**
     * Execute tasks using a pool with a max concurrency.
     */
    run<T>(tasks: Task<Ctx>[], value?: T): Promise<AggregatedResponse>;
    /**
     * Resolve the execution with the current results.
     */
    resolve(): void;
    /**
     * Run a task from the queue, and start the next task one it passes or fails.
     */
    runTask<T>(value?: T): Promise<void>;
    /**
     * Run the next task if there are tasks available in the queue, and the max concurrency isn't met.
     * Otherwise, resolve and exit the current pool.
     */
    nextTask<T>(value?: T): void;
}
