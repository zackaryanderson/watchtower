"use strict";
/**
 * @copyright   2017-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var execa_1 = __importDefault(require("execa"));
var split_1 = __importDefault(require("split"));
var Task_1 = __importDefault(require("./Task"));
var Parallel_1 = __importDefault(require("./executors/Parallel"));
var Pool_1 = __importDefault(require("./executors/Pool"));
var Serial_1 = __importDefault(require("./executors/Serial"));
var Sync_1 = __importDefault(require("./executors/Sync"));
var wrapWithPromise_1 = __importDefault(require("./helpers/wrapWithPromise"));
var constants_1 = require("./constants");
var Routine = /** @class */ (function (_super) {
    __extends(Routine, _super);
    function Routine(key, title, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, title, null, options) || this;
        _this.exit = false;
        _this.key = '';
        _this.routines = [];
        if (!key || typeof key !== 'string') {
            throw new Error('Routine key must be a valid unique string.');
        }
        _this.key = key;
        // We cant pass to super, so bind here
        _this.action = _this.execute.bind(_this);
        // We also need to set it back to pending
        _this.status = constants_1.STATUS_PENDING;
        return _this;
    }
    /**
     * Called once the routine has been configured and is ready to execute.
     */
    Routine.prototype.bootstrap = function () { };
    /**
     * Configure the routine after it has been instantiated.
     */
    Routine.prototype.configure = function (parent) {
        var _this = this;
        this.context = parent.context;
        this.tool = parent.tool;
        // Monitor process
        this.tool.on('exit', function () {
            _this.exit = true;
        });
        // Custom debugger for this routine
        this.debug = this.tool.createDebugger('routine', this.key);
        this.debug('Bootstrapping routine');
        // Initialize routine (this must be last!)
        this.bootstrap();
        return this;
    };
    /**
     * Execute the current routine and return a new value.
     * This method *must* be overridden in a subclass.
     */
    Routine.prototype.execute = function (context, value) {
        throw new Error('execute() must be defined.');
    };
    /**
     * Execute a command with the given arguments and pass the results through a promise.
     */
    Routine.prototype.executeCommand = function (command, args, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var stream = options.sync
            ? execa_1.default.sync(command, args, options)
            : execa_1.default(command, args, options);
        this.tool.console.emit('command', [command, this]);
        // Push chunks to the reporter
        if (!options.sync) {
            var task_1 = options.task || this;
            var handler = function (line) {
                /* istanbul ignore next */
                if (task_1.status === constants_1.STATUS_RUNNING) {
                    task_1.statusText = line;
                    _this.tool.console.emit('command.data', [command, line, _this]);
                }
            };
            stream.stdout.pipe(split_1.default()).on('data', handler);
            stream.stderr.pipe(split_1.default()).on('data', handler);
        }
        // Allow consumer to wrap functionality
        if (typeof options.wrap === 'function') {
            options.wrap(stream);
        }
        return wrapWithPromise_1.default(stream);
    };
    /**
     * Execute routines in parallel.
     */
    Routine.prototype.parallelizeRoutines = function (value, routines) {
        return new Parallel_1.default(this.tool, this.context).run(routines || this.routines, value);
    };
    /**
     * Execute tasks in parallel.
     */
    Routine.prototype.parallelizeTasks = function (value, tasks) {
        return new Parallel_1.default(this.tool, this.context).run(tasks || this.tasks, value);
    };
    /**
     * Add a new routine within this routine.
     */
    Routine.prototype.pipe = function (routine) {
        if (routine instanceof Routine) {
            this.routines.push(routine.configure(this));
        }
        else {
            throw new TypeError('Routines must be an instance of `Routine`.');
        }
        return this;
    };
    /**
     * Execute routines in a pool.
     */
    Routine.prototype.poolRoutines = function (value, options, routines) {
        return new Pool_1.default(this.tool, this.context, options).run(routines || this.routines, value);
    };
    /**
     * Execute tasks in a pool.
     */
    Routine.prototype.poolTasks = function (value, options, tasks) {
        return new Pool_1.default(this.tool, this.context, options).run(tasks || this.tasks, value);
    };
    /**
     * Trigger processes before and after execution.
     */
    Routine.prototype.run = function (context, value, wasParallel) {
        var _this = this;
        if (wasParallel === void 0) { wasParallel = false; }
        if (this.exit) {
            return Promise.reject(new Error('Process has been interrupted.'));
        }
        this.debug('Executing routine');
        var cli = this.tool.console;
        cli.emit('routine', [this, value, wasParallel]);
        return _super.prototype.run.call(this, context, value)
            .then(function (result) {
            cli.emit('routine.pass', [_this, result, wasParallel]);
            return result;
        })
            .catch(function (error) {
            cli.emit('routine.fail', [_this, error, wasParallel]);
            throw error;
        });
    };
    /**
     * Execute routines in sequential (serial) order.
     */
    Routine.prototype.serializeRoutines = function (value, routines) {
        return new Serial_1.default(this.tool, this.context).run(routines || this.routines, value);
    };
    /**
     * Execute tasks in sequential (serial) order.
     */
    Routine.prototype.serializeTasks = function (value, tasks) {
        return new Serial_1.default(this.tool, this.context).run(tasks || this.tasks, value);
    };
    /**
     * Execute routines in sync.
     */
    Routine.prototype.synchronizeRoutines = function (value, routines) {
        return new Sync_1.default(this.tool, this.context).run(routines || this.routines, value);
    };
    /**
     * Execute tasks in sync.
     */
    Routine.prototype.synchronizeTasks = function (value, tasks) {
        return new Sync_1.default(this.tool, this.context).run(tasks || this.tasks, value);
    };
    /**
     * Define an individual task.
     */
    Routine.prototype.task = function (title, action, options) {
        if (typeof action !== 'function') {
            throw new TypeError('Tasks require an executable function.');
        }
        var task = new Task_1.default(title, action.bind(this), options);
        this.tasks.push(task);
        return task;
    };
    return Routine;
}(Task_1.default));
exports.default = Routine;
